use jni::objects::{JClass, JObjectArray, JString};
use jni::sys::jlong;
use jni::JNIEnv;
use tk::normalizers::{
    BertNormalizer, Lowercase, Nmt, NormalizerWrapper, Precompiled, Prepend, Replace, Strip,
    StripAccents, NFC, NFD, NFKC, NFKD,
};
use tk::{NormalizedString, Normalizer};
use tokenizers as tk;

use tk::models::bpe::{BpeBuilder, Merges, Vocab, BPE};
use tk::models::unigram::Unigram;
use tk::models::wordlevel::WordLevel;
use tk::models::wordpiece::{WordPiece, WordPieceBuilder};
use tk::models::ModelWrapper;
use tk::{Model, Token};

use crate::java_classable::JavaClassable;

struct JModel {
    handle: jlong,
}

unsafe impl JavaClassable for JModel {
    const LOC: &'static str = "dev/gigapixel/tok4j/Model";
    const PATH: &'static str = "dev.gigapixel.tok4j.Model";
    type RustType = ModelWrapper;
    fn new_from_handle(handle: jlong) -> Self {
        JModel { handle }
    }
}

// fn __getstate__(&self, py: Python) -> PyResult<PyObject> {
//     let data = serde_json::to_string(&self.model).map_err(|e| {
//         exceptions::PyException::new_err(format!(
//             "Error while attempting to pickle Model: {}",
//             e
//         ))
//     })?;
//     Ok(PyBytes::new(py, data.as_bytes()).to_object(py))
// }
//
// fn __setstate__(&mut self, py: Python, state: PyObject) -> PyResult<()> {
//     match state.extract::<&PyBytes>(py) {
//         Ok(s) => {
//             self.model = serde_json::from_slice(s.as_bytes()).map_err(|e| {
//                 exceptions::PyException::new_err(format!(
//                     "Error while attempting to unpickle Model: {}",
//                     e
//                 ))
//             })?;
//             Ok(())
//         }
//         Err(e) => Err(e),
//     }
// }
//
/// Tokenize a sequence
///
/// Args:
///     sequence (:obj:`str`):
///         A sequence to tokenize
///
/// Returns:
///     A :obj:`List` of :class:`~tokenizers.Token`: The generated tokens

//
#[jni_fn("dev.gigapixel.tok4j.Model")]
pub fn tokenize<'local>(
    mut env: JNIEnv<'local>,
    _class: JClass<'local>,
    handle: jlong,
    sequence: JString<'local>,
) -> JObjectArray<'local> {
    let mut pinned = unsafe { JModel::new_from_handle(handle).rust_type() };
    let sequence: String = env.get_string(&sequence).into();
    let result = self.model.read().unwrap().tokenize(sequence);
    todo!()
}

// Get the ID associated to a token
//
// Args:
//     token (:obj:`str`):
//         A token to convert to an ID
//
// Returns:
//     :obj:`int`: The ID associated to the token
// #[pyo3(text_signature = "(self, tokens)")]
// fn token_to_id(&self, token: &str) -> Option<u32> {
//     self.model.read().unwrap().token_to_id(token)
// }

// Get the token associated to an ID
//
// Args:
//     id (:obj:`int`):
//         An ID to convert to a token
//
// Returns:
//     :obj:`str`: The token associated to the ID
// #[pyo3(text_signature = "(self, id)")]
// fn id_to_token(&self, id: u32) -> Option<String> {
//     self.model.read().unwrap().id_to_token(id)
// }

// Save the current model
//
// Save the current model in the given folder, using the given prefix for the various
// files that will get created.
// Any file with the same name that already exists in this folder will be overwritten.
//
// Args:
//     folder (:obj:`str`):
//         The path to the target folder in which to save the various files
//
//     prefix (:obj:`str`, `optional`):
//         An optional prefix, used to prefix each file name
//
// Returns:
//     :obj:`List[str]`: The list of saved files
// #[pyo3(text_signature = "(self, folder, prefix)")]
// fn save<'a>(
//     &self,
//     py: Python<'_>,
//     folder: &str,
//     mut prefix: Option<&'a str>,
//     name: Option<&'a str>,
// ) -> PyResult<Vec<String>> {
//     if name.is_some() {
//         deprecation_warning(
//             py,
//             "0.10.0",
//             "Parameter `name` of Model.save has been renamed `prefix`",
//         )?;
//         if prefix.is_none() {
//             prefix = name;
//         }
//     }
//
//     let saved: PyResult<Vec<_>> =
//         ToPyResult(self.model.read().unwrap().save(Path::new(folder), prefix)).into();
//
//     Ok(saved?
//         .into_iter()
//         .map(|path| path.to_string_lossy().into_owned())
//         .collect())
// }

// Get the associated :class:`~tokenizers.trainers.Trainer`
//
// Retrieve the :class:`~tokenizers.trainers.Trainer` associated to this
// :class:`~tokenizers.models.Model`.
//
// Returns:
//     :class:`~tokenizers.trainers.Trainer`: The Trainer used to train this model
// #[pyo3(text_signature = "(self)")]
// fn get_trainer(&self, py: Python<'_>) -> PyResult<PyObject> {
//     PyTrainer::from(self.model.read().unwrap().get_trainer()).get_as_subtype(py)
// }
